#compdef simctl

_simctl() {
  _arguments \
    '--set: :_files -/' \
    '--profiles: :_files -/' \
    ': :_commands' \
    '*:: :_options'
}

_commands() {
  local -a commands
  commands=(
    'create:Create a new device.'
    'clone:Clone an existing device.'
    'upgrade:Upgrade a device to a newer runtime.'
    'delete:Delete specified devices, unavailable devices, or all devices.'
    'pair:Create a new watch and phone pair.'
    'unpair:Unpair a watch and phone pair.'
    'pair_activate:Unpair a watch and phone pair.'
    'erase:Erase a device'"'"'s contents and settings.'
    'boot:Boot a device or device pair.'
    'shutdown:Shutdown a device.'
    'rename:Rename a device.'
    'getenv:Print an environment variable from a running device.'
    'openurl:Open a URL in a device.'
    'addmedia:Add photos, live photos, videos, or contacts to the library of a device.'
    'install:Install an app on a device.'
    'uninstall:Uninstall an app from a device.'
    'get_app_container:Print the path of the installed app'"'"'s container'
    'install_app_data:Install an xcappdata package to a device, replacing the current contents of the container.'
    'launch:Launch an application by identifier on a device.'
    'terminate:Terminate an application by identifier on a device.'
    'spawn:Spawn a process by executing a given executable on a device.'
    'list:List available devices, device types, runtimes, or device pairs.'
    'icloud_sync:Trigger iCloud sync on a device.'
    'pbsync:Sync the pasteboard content from one pasteboard to another.'
    'pbcopy:Copy standard input onto the device pasteboard.'
    'pbpaste:Print the contents of the device'"'"'s pasteboard to standard output.'
    'help:Prints the usage for a given subcommand.'
    'io:Set up a device IO operation.'
    'diagnose:Collect diagnostic information and logs.'
    'logverbose:enable or disable verbose logging for a device'
  )
  _describe subcommand commands
}

_options() {
  case $line[1] in

    (create)
      _arguments \
        ':name:' \
        ':device type id:_devicetypes' \
        '::runtime id:{DEVICETYPE=${(Q)words[CURRENT-1]} _runtimes}'
      ;;

    (clone)
      _arguments \
        ':device:{FILTER=available_shutdown _devices}' \
        ':name:' \
        '::destination device set:_files -/'
      ;;

    (upgrade)
      _arguments \
        ':device:{FILTER=shutdown _devices}' \
        ':runtime id:{DEVICE=${(Q)words[CURRENT-1]} _runtimes}'
      ;;

    (delete)
      _arguments \
        '*: :{_devices_unavailable; _devices_all; _devices}'
      ;;

    (pair)
      _arguments \
        ':device:{FILTER=watches _devices}' \
        ':device:{FILTER=phones _devices}'
      ;;

    (unpair|pair_activate)
      _arguments \
        ':pair:_pairs'
      ;;

    (erase)
      _arguments \
        '*: :{_devices_all; FILTER=available_shutdown _devices}'
      ;;

    (boot)
      _arguments \
        ': :{FILTER=available_shutdown _devices; _pairs}' \
        '--disabledJob=-[Disables the given launchd job.]' \
        '--enabledJob=-[Enables the given launchd job when it would normally be disabled.]'
      ;;

    (shutdown)
      _arguments \
        '*: :{_devices_all; FILTER=booted _devices}'
      ;;

    (rename)
      _arguments \
        ':device:_devices' \
        ':name:'
      ;;

    (getenv)
      _arguments \
        ':device:{FILTER=booted _devices}' \
        ':variable name:'
      ;;

    (openurl)
      _arguments \
        ':device:{FILTER=booted _devices}' \
        ':url:{DEVICE=${(Q)words[CURRENT-1]} _urls}'
      ;;

    (addmedia)
      _arguments \
        ':device:{FILTER=booted _devices}' \
        '*:path:_files'
      ;;

    (install)
      _arguments \
        ':device:{FILTER=booted _devices}' \
        ':path:_files -/'
      ;;

    (uninstall)
      _arguments \
        ':device:{FILTER=booted _devices}' \
        ':app bundle identifier:{DEVICE=${(Q)words[CURRENT-1]} APPLICATION_TYPE=User _bundle_identifiers}'
      ;;

    (get_app_container)
      _arguments \
        ':device:{FILTER=booted _devices}' \
        ':app bundle identifier:{DEVICE=${(Q)words[CURRENT-1]} _bundle_identifiers}' \
        ':container:{DEVICE=${(Q)words[CURRENT-2]} BUNDLE_IDENTIFIER=${(Q)words[CURRENT-1]} _containers}'
      ;;

    (install_app_data)
      _arguments \
        ':device:{FILTER=booted _devices}' \
        ':path:_files -g \*.xcappdata'
      ;;

    (launch)
      _arguments \
        '(-w --wait-for-debugger)'{-w,--wait-for-debugger} \
        '(--console-pty --stdout --stderr)--console[Block and print the application'"'"'s stdout and stderr to the current terminal.]' \
        '(--console --stdout --stderr)--console-pty[Block and print the application'"'"'s stdout and stderr to the current terminal via a PTY.]' \
        '(--console --console-pty)--stdout=-[Redirect the application'"'"'s standard output to a file.]: :_files' \
        '(--console --console-pty)--stderr=-[Redirect the application'"'"'s standard error to a file.]: :_files' \
        '--terminate-running-process[Terminate any running copy of the application.]' \
        '(-):device:{FILTER=booted _devices}' \
        ':app bundle identifier:{DEVICE=${(Q)words[CURRENT-1]} _bundle_identifiers}' \
        '*::argv:'
      ;;

    (terminate)
      _arguments \
        ':device:{FILTER=booted _devices}' \
        ':app bundle identifier:{DEVICE=${(Q)words[CURRENT-1]} _bundle_identifiers}'
      ;;

    (spawn)
      _arguments \
        '(-w --wait-for-debugger)'{-w,--wait-for-debugger} \
        '(-s --standalone)'{-s,--standalone} \
        '(--arch)-a:arch:' \
        '(-a)--arch=-:arch:' \
        '(-):device:{FILTER=booted _devices}' \
        ':path:_files' \
        '*::argv:'
      ;;

    (list)
      _arguments \
        '(-j --json)'{-j,--json}'[Print as JSON.]' \
        '-v[More verbose output]' \
        ':list:(devices devicetypes runtimes pairs)' \
        '::search term:(available)'
      ;;

    (icloud_sync)
      _arguments \
        ':device:{FILTER=booted _devices}'
      ;;

    (pbsync)
      _arguments \
        '-p[causes simctl to use promise data for secondary types]' \
        '-v' \
        ':source device:{_host; FILTER=booted _devices}' \
        ':destination device:{_host; FILTER=booted _devices}'
      ;;

    (pbcopy|pbpaste)
      _arguments \
        '-v' \
        ':device:{FILTER=booted _devices}'
      ;;

    (help)
      _arguments \
        ': :_commands'
      ;;

    (io)
      _arguments \
        ':device:{FILTER=booted _devices}' \
        '*:: :_io'
      ;;

    (diagnose)
      _arguments \
	'-b[Do NOT show the resulting archive in a Finder window upon completion.]' \
	'-X[Run all diagnostics with no timeout. It ignores the --timeout value if it is specified.]' \
	'--timeout=-[Specify a duration (in seconds) to wait for the log collection before timeout.]:duration:' \
	'--output=-[Specify the output directory.]:path:_files -/' \
	'--no-archive[Do not create an archive, leave the collected files uncompressed.]' \
	'--all-logs[Include all device logs, even for non-booted devices.]' \
	'--data-containers[Include booted device(s) data directory.]' \
	'--udid=-[Collect diagnostics only from the specified device.]:device:_devices'
      ;;

    (logverbose)
      _arguments \
        '::device:{FILTER=booted _devices}' \
        ':state:(enable disable)'
      ;;

  esac
}

_io() {
  _arguments \
    ':operation:_io_operations' \
    '*::arguments:_io_op_arguments'
}

_io_operations() {
  local -a operations
  operations=(
    'enumerate:Lists all available IO ports and descriptor states.'
    'recordVideo:Records the display to a QuickTime movie at the specified file or url.'
    'screenshot:Saves a screenshot as a PNG to the specified file or url(use "-" for stdout).'
  )
  _describe operation operations
}

_io_op_arguments() {
  case $line[1] in

    (enumerate)
      _arguments \
        '--poll[Poll after enumeration.]'
      ;;

    (recordVideo)
      _arguments \
        '--codec=-[Specifies the codec type]:codec:(h264 hevc)' \
        '--display=-:display:(internal external)' \
        '--mask=-[For non-rectangular displays, handle the mask by policy]:policy:_io_record_masks' \
        '--force[Force the output file to be written to, even if the file already exists.]' \
        ':file or url:_files'
      ;;

    (screenshot)
      _arguments \
        '--type=-:type:(png tiff bmp gif jpeg)' \
        '--display=-:display:(internal external)' \
        '--mask=-[For non-rectangular displays, handle the mask by policy]:policy:_io_screenshot_masks' \
        ':file or url:_files'
      ;;

  esac
}

_io_record_masks() {
  local -a masks
  masks=(
    'ignored:The mask is ignored and the unmasked framebuffer is saved.'
    'alpha:Not supported, but retained for compatibility; the mask is rendered black.'
    'black:The mask is rendered black.'
  )
  _describe mask masks
}

_io_screenshot_masks() {
  local -a masks
  masks=(
    'ignored:The mask is ignored and the unmasked framebuffer is saved.'
    'alpha:The mask is used as premultiplied alpha.'
    'black:The mask is rendered black.'
  )
  _describe mask masks
}

_devicetypes() {
  local -a devicetypes
  devicetypes=(${(f)"$(xcrun simctl list devicetypes -j | jq -r '.devicetypes[].name')"})
  _describe devicetype devicetypes
}

_runtimes() {
  local -a runtimes
  runtimes=(${(f)"$(xcrun simctl list -j | jq -r '
    (
      $ENV.DEVICETYPE
      // first(.devices[][] | select(.udid == ($ENV.DEVICE // "none"))).deviceTypeIdentifier
      // ""
    ) as $devicetype
    | (
      .devicetypes | map(select(
        ((.identifier | ascii_downcase) | contains($devicetype | ascii_downcase))
        or ((.name | ascii_downcase) | contains($devicetype | ascii_downcase))
      )) | INDEX(.identifier)
    ) as $devicetypes
    | .runtimes |= (sort_by([{iOS:"x"}[.platform] // .platform, .buildversion]) | reverse)
    | .runtimes[]
    | select(.isAvailable)
    | select(any($devicetypes[.supportedDeviceTypes[].identifier]; .))
    | "\(.identifier):\(.name) (\(.version) - \(.buildversion))"
  ')"})
  _describe -V runtime runtimes
}

_devices() {
  local -a devices
  devices=(${(f)"$(xcrun simctl list -j | jq -r '
    (.devicetypes | INDEX(.identifier)) as $devicetypes
    | (.runtimes | INDEX(.identifier)) as $runtimes
    | .devices |= with_entries(.value[].runtime = $runtimes[.key])
    | .devices[][] |= (.devicetype = $devicetypes[.deviceTypeIdentifier])
    | [.devices[][]] | sort_by(.logPathSize) | reverse[]
    | select(contains(
      {
        available_shutdown: {isAvailable: true, state: "Shutdown"},
        shutdown: {state: "Shutdown"},
        booted: {state: "Booted"},
        watches: {devicetype: {productFamily: "Apple Watch"}},
        phones: {devicetype: {productFamily: "iPhone"}},
      }[$ENV.FILTER // "none"] // {}
    ))
    | "\(.udid):\(.name) (\(.devicetype.name // "unknown type"), \(.runtime.name // .availabilityError)) (\(.state))"
  ')"})
  _describe -V device devices
}

_devices_all() {
  local -a devices
  devices=(
    all:'All devices'
  )
  _describe -V special devices
}

_devices_unavailable() {
  local -a devices
  devices=(
    unavailable:'Devices not supported by the current Xcode SDK'
  )
  _describe -V special devices
}

_pairs() {
  local -a pairs
  pairs=(${(f)"$(xcrun simctl list pairs -j | jq -r '
    .pairs | to_entries[] |
    "\(.key):\(.value.watch.name) - \(.value.phone.name) \(.value.state)"
  ')"})
  _describe pair pairs
}

_urls() {
  local -a urls
  urls+=('http\://' 'https\://')
  urls+=(${(f)"$(
    xcrun simctl listapps "$DEVICE" 2>/dev/null |
      plutil -convert json - -o - |
      jq -r 2>/dev/null '[.[]] | sort_by(.ApplicationType) | reverse[].Path' |
      while read app; do plutil -convert json "$app"/Info.plist -o -; done |
      jq -r '[.CFBundleURLTypes[]?.CFBundleURLSchemes[]?] - ["http", "https"] | .[] + "\\:"'
  )"})
  _describe -V url urls
}

_bundle_identifiers() {
  local -a identifiers
  identifiers=(${(f)"$(
    xcrun simctl listapps "$DEVICE" 2>/dev/null |
      plutil -convert json - -o - |
      jq -r 2>/dev/null '
        [.[]] | sort_by(.ApplicationType) | reverse[]
        | select(.ApplicationType == ($ENV.APPLICATION_TYPE // .ApplicationType))
        | "\(.CFBundleIdentifier):\(.CFBundleDisplayName)"
        + if .ApplicationType == "User" then " (\(.CFBundleVersion))" else "" end
      '
  )"})
  _describe -V 'bundle identifier' identifiers
}

_containers() {
  local -a containers
  containers+=(app data groups)
  containers+=(${(f)"$(
    xcrun simctl listapps "$DEVICE" 2>/dev/null |
      plutil -convert json - -o - |
      jq -r 2>/dev/null '.[] | select(.CFBundleIdentifier == $ENV.BUNDLE_IDENTIFIER) | .GroupContainers | keys[]'
    )"})
  _describe -V container containers
}

_host() {
  local -a host
  host=(
    host
  )
  _describe -V device host
}
